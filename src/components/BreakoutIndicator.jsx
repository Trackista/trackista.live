import { useState, useEffect } from 'react';

/**
 * –†–∞—Å—á–µ—Ç Volume Profile –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –æ–±—ä–µ–º–∞ –ø–æ —Ü–µ–Ω–æ–≤—ã–º —É—Ä–æ–≤–Ω—è–º
 * @param {Array} candles - –º–∞—Å—Å–∏–≤ —Å–≤–µ—á–µ–π [{timestamp, open, high, low, close, volume}]
 * @param {Object} options - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–∞—Å—á–µ—Ç–∞
 * @returns {Object} –ø—Ä–æ—Ñ–∏–ª—å –æ–±—ä–µ–º–∞ —Å POC –∏ Value Area
 */
function buildVolumeProfile(candles, {
  priceStep,
  session = null,
  bodyWeight = 0.7,
  valueAreaPct = 0.7,
} = {}) {
  if (!Array.isArray(candles) || !candles.length) return null;
  if (!priceStep || priceStep <= 0) throw new Error('priceStep must be > 0');

  // 1) –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Å–µ—Å—Å–∏–∏ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
  let data = candles;
  const toTs = v => (v instanceof Date ? v.getTime() : Number(v));
  if (session && session.from != null && session.to != null) {
    const fromTs = toTs(session.from);
    const toTs_ = toTs(session.to);
    data = candles.filter(c => {
      const t = toTs(c.timestamp || c.time);
      return t >= fromTs && t <= toTs_;
    });
  }
  if (!data.length) return null;

  // 2) –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–±—â–∏–π —Ü–µ–Ω–æ–≤–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω
  let minPrice = Infinity, maxPrice = -Infinity;
  for (const c of data) {
    if (c.low < minPrice) minPrice = c.low;
    if (c.high > maxPrice) maxPrice = c.high;
  }
  
  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –Ω–∞ —à–∞–≥
  const floorTo = (x, step) => Math.floor(x / step) * step;
  const ceilTo  = (x, step) => Math.ceil (x / step) * step;
  minPrice = floorTo(minPrice, priceStep);
  maxPrice = ceilTo(maxPrice, priceStep);

  const binCount = Math.max(1, Math.round((maxPrice - minPrice) / priceStep));
  const bins = new Float64Array(binCount).fill(0);

  // 3) –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–±—ä—ë–º —Å–≤–µ—á–∏ –ø–æ –∫–æ—Ä–∑–∏–Ω–∞–º
  for (const c of data) {
    const lo = Math.min(c.low, c.high);
    const hi = Math.max(c.low, c.high);
    if (hi === lo || c.volume <= 0) continue;

    const bodyLo = Math.min(c.open, c.close);
    const bodyHi = Math.max(c.open, c.close);

    // –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–µ–ª–∞ (–≤–Ω—É—Ç—Ä–∏ —Ç–µ–Ω–∏)
    const bLo = Math.max(lo, Math.min(bodyLo, bodyHi));
    const bHi = Math.min(hi, Math.max(bodyLo, bodyHi));

    const bodyRange = Math.max(0, bHi - bLo);
    const tailRange = Math.max(0, (hi - lo) - bodyRange);

    const bodyVol = bodyRange > 0 ? c.volume * bodyWeight : 0;
    const tailVol = c.volume - bodyVol;

    // –•–µ–ª–ø–µ—Ä —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è: —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ –ø–æ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—é —Å –∫–æ—Ä–∑–∏–Ω–æ–π
    const addRange = (rangeLo, rangeHi, vol) => {
      if (vol <= 0 || rangeHi <= rangeLo) return;
      const totalRange = rangeHi - rangeLo;
      const startIdx = Math.max(0, Math.floor((rangeLo - minPrice) / priceStep));
      const endIdx   = Math.min(binCount - 1, Math.floor((rangeHi - minPrice - 1e-12) / priceStep));
      for (let idx = startIdx; idx <= endIdx; idx++) {
        const binLo = minPrice + idx * priceStep;
        const binHi = binLo + priceStep;
        const overlap = Math.max(0, Math.min(rangeHi, binHi) - Math.max(rangeLo, binLo));
        if (overlap > 0) {
          const part = (overlap / totalRange) * vol;
          bins[idx] += part;
        }
      }
    };

    // –¢–µ–Ω–∏: –Ω–∏–∂–Ω—è—è –∏ –≤–µ—Ä—Ö–Ω—è—è
    if (tailRange > 0) {
      if (bLo > lo) addRange(lo, bLo, tailVol * ((bLo - lo) / tailRange));
      if (hi > bHi) addRange(bHi, hi, tailVol * ((hi - bHi) / tailRange));
    }
    // –¢–µ–ª–æ
    if (bodyRange > 0) {
      addRange(bLo, bHi, bodyVol);
    }
  }

  // 4) –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –º–∞—Å—Å–∏–≤ —Ç–æ—á–µ–∫
  const histogram = Array.from({ length: binCount }, (_, i) => ({
    price: +(minPrice + i * priceStep).toFixed(10),
    volume: bins[i],
  }));

  // 5) –ú–µ—Ç—Ä–∏–∫–∏: —Å—É–º–º–∞—Ä–Ω—ã–π –æ–±—ä—ë–º, POC, Value Area 70%
  const totalVol = histogram.reduce((s, x) => s + x.volume, 0);
  let pocIdx = 0;
  for (let i = 1; i < histogram.length; i++) {
    if (histogram[i].volume > histogram[pocIdx].volume) pocIdx = i;
  }

  // Value Area: —Ä–∞—Å—à–∏—Ä—è–µ–º –æ—Ç POC, –ø–æ–∫–∞ –Ω–µ —Å–æ–±–µ—Ä—ë–º valueAreaPct –æ—Ç totalVol
  let cum = histogram[pocIdx].volume;
  let left = pocIdx - 1;
  let right = pocIdx + 1;
  while (cum < totalVol * valueAreaPct && (left >= 0 || right < histogram.length)) {
    const leftVol = left >= 0 ? histogram[left].volume : -1;
    const rightVol = right < histogram.length ? histogram[right].volume : -1;

    if (rightVol > leftVol) {
      cum += Math.max(0, rightVol);
      right++;
    } else {
      cum += Math.max(0, leftVol);
      left--;
    }
  }
  const valIdx = Math.max(0, left + 1);
  const vahIdx = Math.min(histogram.length - 1, right - 1);

  return {
    histogram,
    poc: { price: histogram[pocIdx].price, volume: histogram[pocIdx].volume, index: pocIdx },
    valueArea: {
      from: histogram[valIdx].price,
      to: histogram[vahIdx].price,
      coverage: valueAreaPct,
    },
    totalVolume: totalVol,
    meta: { priceStep, bodyWeight, valueAreaPct, minPrice, maxPrice },
  };
}

/**
 * –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø—Ä–æ–±–æ—è —É—Ä–æ–≤–Ω–µ–π —Å Volume Profile
 * –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ —Å–≤–µ—á–µ–π –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ –ø—Ä–æ–±–æ–∏
 */
export const BreakoutIndicator = {
  /**
   * –í—ã—á–∏—Å–ª—è–µ—Ç Volume Profile –¥–ª—è –≤–∏–¥–∏–º—ã—Ö —Å–≤–µ—á–µ–π
   * @param {Array} klineData - –º–∞—Å—Å–∏–≤ –¥–∞–Ω–Ω—ã—Ö —Å–≤–µ—á–µ–π
   * @returns {Object} –¥–∞–Ω–Ω—ã–µ Volume Profile
   */
  calculateVolumeProfile: (klineData) => {
    if (!klineData || klineData.length === 0) {
      return { success: false, message: '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ Volume Profile' };
    }

    try {
      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —à–∞–≥ —Ü–µ–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö
      const prices = klineData.flatMap(c => [c.high, c.low]);
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      const priceRange = maxPrice - minPrice;
      
      // –í—ã–±–∏—Ä–∞–µ–º —à–∞–≥ —Ü–µ–Ω—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è 50-100 –∫–æ—Ä–∑–∏–Ω
      const targetBins = 75;
      const priceStep = priceRange / targetBins;
      
      // –ê–¥–∞–ø—Ç–∏—Ä—É–µ–º —à–∞–≥ –∫ —Ä–∞–∑—É–º–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏—è–º
      let adaptedStep;
      if (priceStep > 100) adaptedStep = Math.ceil(priceStep / 10) * 10;
      else if (priceStep > 10) adaptedStep = Math.ceil(priceStep);
      else if (priceStep > 1) adaptedStep = Math.ceil(priceStep * 10) / 10;
      else if (priceStep > 0.1) adaptedStep = Math.ceil(priceStep * 100) / 100;
      else adaptedStep = Math.ceil(priceStep * 1000) / 1000;

      console.log('üìä –†–∞—Å—á–µ—Ç Volume Profile:', {
        priceRange: priceRange.toFixed(4),
        targetBins,
        calculatedStep: priceStep.toFixed(6),
        adaptedStep: adaptedStep.toFixed(6),
        dataPoints: klineData.length
      });

      const profile = buildVolumeProfile(klineData, {
        priceStep: adaptedStep,
        bodyWeight: 0.7,
        valueAreaPct: 0.7
      });

      if (!profile) {
        return { success: false, message: '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å Volume Profile' };
      }

      return {
        success: true,
        profile,
        message: `Volume Profile: POC ${profile.poc.price.toFixed(4)}, VA ${profile.valueArea.from.toFixed(4)}-${profile.valueArea.to.toFixed(4)}`
      };

    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ Volume Profile:', error);
      return { success: false, message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ Volume Profile' };
    }
  },

  /**
   * –†–∏—Å—É–µ—Ç –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ
   * @param {Object} chart - —ç–∫–∑–µ–º–ø–ª—è—Ä KLineChart
   * @param {Array} klineData - –º–∞—Å—Å–∏–≤ –¥–∞–Ω–Ω—ã—Ö —Å–≤–µ—á–µ–π
   * @param {string} interval - —Ç–µ–∫—É—â–∏–π —Ç–∞–π–º—Ñ—Ä–µ–π–º
   * @returns {Object} –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–Ω—ã—Ö –ª–∏–Ω–∏—è—Ö
   */
  drawSupportResistanceLines: (chart, klineData, interval = '1m') => {
    if (!chart || !klineData || klineData.length === 0) {
      return { success: false, message: '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞' };
    }

    let dataToAnalyze;
    let periodDescription;

    // –î–ª—è –≤—Å–µ—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤ - –±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –≤–∏–¥–∏–º—ã–µ –Ω–∞ —ç–∫—Ä–∞–Ω–µ —Å–≤–µ—á–∏
    try {
      const visibleRange = chart.getVisibleRange();
      console.log('üìä –í–∏–¥–∏–º—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω:', JSON.stringify(visibleRange, null, 2));
      
      if (visibleRange && visibleRange.from !== undefined && visibleRange.to !== undefined) {
        // –í–∏–¥–∏–º—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã, –Ω–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ!
        let startIndex = Math.max(0, Math.floor(visibleRange.from));
        let endIndex = Math.min(klineData.length, Math.ceil(visibleRange.to));
        
        // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –∏–Ω–¥–µ–∫—Å—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã
        if (startIndex >= klineData.length) startIndex = klineData.length - 100;
        if (endIndex <= startIndex) endIndex = startIndex + 50;
        if (endIndex > klineData.length) endIndex = klineData.length;
        
        dataToAnalyze = klineData.slice(startIndex, endIndex);
        periodDescription = `–≤–∏–¥–∏–º—ã—Ö –Ω–∞ —ç–∫—Ä–∞–Ω–µ (${dataToAnalyze.length} —Å–≤–µ—á–µ–π, –∏–Ω–¥–µ–∫—Å—ã ${startIndex}-${endIndex})`;
        
        console.log('‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–∏–¥–∏–º—ã–µ —Å–≤–µ—á–∏:', {
          originalFrom: visibleRange.from,
          originalTo: visibleRange.to,
          startIndex,
          endIndex,
          totalCandles: klineData.length,
          visibleCandles: dataToAnalyze.length,
          firstCandle: dataToAnalyze[0],
          lastCandle: dataToAnalyze[dataToAnalyze.length - 1]
        });
      } else {
        // Fallback: –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 —Å–≤–µ—á–µ–π –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏
        dataToAnalyze = klineData.slice(-100);
        periodDescription = `–ø–æ—Å–ª–µ–¥–Ω–∏—Ö 100 —Å–≤–µ—á–µ–π (fallback)`;
        
        console.log('‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º fallback - –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 —Å–≤–µ—á–µ–π');
      }
    } catch (error) {
      console.warn('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≤–∏–¥–∏–º–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞:', error);
      dataToAnalyze = klineData.slice(-100);
      periodDescription = `–ø–æ—Å–ª–µ–¥–Ω–∏—Ö 100 —Å–≤–µ—á–µ–π (–ø–æ—Å–ª–µ –æ—à–∏–±–∫–∏)`;
    }
    
    if (dataToAnalyze.length === 0) {
      return { success: false, message: '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞' };
    }

    // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Ü–µ–Ω—ã —Å—Ä–µ–¥–∏ –≤–∏–¥–∏–º—ã—Ö —Å–≤–µ—á–µ–π
    const highestPrice = Math.max(...dataToAnalyze.map(candle => candle.high));
    const lowestPrice = Math.min(...dataToAnalyze.map(candle => candle.low));

    // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –ª–∏–Ω–∏–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å)
    try {
      chart.removeOverlay();
    } catch (e) {
      console.log('–ù–µ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –ª–∏–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è');
    }

    console.log('üìä –ù–∞—á–∏–Ω–∞–µ–º –∞–Ω–∞–ª–∏–∑ —ç–∫—Å—Ç—Ä–µ–º—É–º–æ–≤:', {
      totalCandles: klineData.length,
      analyzedCandles: dataToAnalyze.length,
      highest: highestPrice,
      lowest: lowestPrice
    });

    // –î–æ–±–∞–≤–ª—è–µ–º –ª–∏–Ω–∏–∏ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫
    try {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π API KLineCharts –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ñ–∏–≥—É—Ä
      const firstTimestamp = dataToAnalyze[0].timestamp;
      const lastTimestamp = dataToAnalyze[dataToAnalyze.length - 1].timestamp;

      // –°–æ–∑–¥–∞–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—É—é –ª–∏–Ω–∏—é —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
      const resistanceOverlay = {
        name: 'segment',
        id: 'resistance_line',
        groupId: 'support_resistance',
        points: [
          { timestamp: firstTimestamp, value: highestPrice },
          { timestamp: lastTimestamp, value: highestPrice }
        ],
        styles: {
          line: {
            color: '#007bff',
            size: 1,
            style: 'solid'
          }
        },
        extendLeft: true,
        extendRight: true
      };

      // –°–æ–∑–¥–∞–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—É—é –ª–∏–Ω–∏—é –ø–æ–¥–¥–µ—Ä–∂–∫–∏
      const supportOverlay = {
        name: 'segment',
        id: 'support_line', 
        groupId: 'support_resistance',
        points: [
          { timestamp: firstTimestamp, value: lowestPrice },
          { timestamp: lastTimestamp, value: lowestPrice }
        ],
        styles: {
          line: {
            color: '#007bff',
            size: 1,
            style: 'solid'
          }
        },
        extendLeft: true,
        extendRight: true
      };

      console.log('üéØ –°–æ–∑–¥–∞–µ–º –ª–∏–Ω–∏–∏:', {
        resistance: { timestamp: firstTimestamp, value: highestPrice },
        support: { timestamp: firstTimestamp, value: lowestPrice },
        timeRange: `${firstTimestamp} - ${lastTimestamp}`,
        resistanceOverlay: JSON.stringify(resistanceOverlay, null, 2),
        supportOverlay: JSON.stringify(supportOverlay, null, 2)
      });

      // –°–æ–∑–¥–∞–µ–º –æ–≤–µ—Ä–ª–µ–∏
      const resistanceId = chart.createOverlay(resistanceOverlay);
      const supportId = chart.createOverlay(supportOverlay);
      
      console.log('‚úÖ –õ–∏–Ω–∏–∏ —Å–æ–∑–¥–∞–Ω—ã —Å ID:', { resistanceId, supportId });
      
      return {
        success: true,
        message: `–≠–∫—Å—Ç—Ä–µ–º—É–º—ã —Å—Ä–µ–¥–∏ ${periodDescription}: –ü–æ–¥–¥–µ—Ä–∂–∫–∞ ${lowestPrice.toFixed(4)}, –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ ${highestPrice.toFixed(4)}`,
        supportLevel: lowestPrice,
        resistanceLevel: highestPrice,
        candlesAnalyzed: dataToAnalyze.length,
        analysisType: 'visible_range'
      };
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∏—Å–æ–≤–∞–Ω–∏–∏ –ª–∏–Ω–∏–π:', error);
      
      // –ü—Ä–æ–±—É–µ–º —Å–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π —Å–ø–æ—Å–æ–± - —Ä–∏—Å–æ–≤–∞–Ω–∏–µ —Ñ–∏–≥—É—Ä –≤—Ä—É—á–Ω—É—é
      try {
        console.log('üîÑ –ü—Ä–æ–±—É–µ–º –ø—Ä–æ—Å—Ç—ã–µ –ª–∏–Ω–∏–∏...');
        
        // –ü—Ä–æ—Å—Ç—ã–µ –ª–∏–Ω–∏–∏ –±–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è
        const simpleResistance = {
          name: 'line',
          points: [
            { timestamp: dataToAnalyze[0].timestamp, value: highestPrice },
            { timestamp: dataToAnalyze[dataToAnalyze.length - 1].timestamp, value: highestPrice }
          ],
          styles: {
            line: { color: '#007bff', size: 1 }
          }
        };

        const simpleSupport = {
          name: 'line',
          points: [
            { timestamp: dataToAnalyze[0].timestamp, value: lowestPrice },
            { timestamp: dataToAnalyze[dataToAnalyze.length - 1].timestamp, value: lowestPrice }
          ],
          styles: {
            line: { color: '#007bff', size: 1 }
          }
        };

        chart.createOverlay(simpleResistance);
        chart.createOverlay(simpleSupport);

        return {
          success: true,
          message: `–ü—Ä–æ—Å—Ç—ã–µ –ª–∏–Ω–∏–∏ —Å–æ–∑–¥–∞–Ω—ã. –ü–æ–¥–¥–µ—Ä–∂–∫–∞: ${lowestPrice.toFixed(4)}, –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ: ${highestPrice.toFixed(4)}`,
          supportLevel: lowestPrice,
          resistanceLevel: highestPrice,
          candlesAnalyzed: dataToAnalyze.length,
          analysisType: 'visible_range'
        };
        
      } catch (altError) {
        console.error('‚ùå –ò –ø—Ä–æ—Å—Ç—ã–µ –ª–∏–Ω–∏–∏ –Ω–µ —Ä–∞–±–æ—Ç–∞—é—Ç:', altError);
        return {
          success: false,
          message: `–õ–∏–Ω–∏–∏ –Ω–µ —Ä–∏—Å—É—é—Ç—Å—è. –ü–æ–¥–¥–µ—Ä–∂–∫–∞: ${lowestPrice.toFixed(4)}, –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ: ${highestPrice.toFixed(4)}. –î–∞–Ω–Ω—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã –≤ –∫–æ–Ω—Å–æ–ª–∏.`
        };
      }
    }
  },

  /**
   * –†–∏—Å—É–µ—Ç –ª–∏–Ω–∏–∏ Volume Profile –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ (POC –∏ Value Area)
   * @param {Object} chart - —ç–∫–∑–µ–º–ø–ª—è—Ä KLineChart
   * @param {Object} volumeProfile - –¥–∞–Ω–Ω—ã–µ Volume Profile
   * @param {Array} klineData - –º–∞—Å—Å–∏–≤ –¥–∞–Ω–Ω—ã—Ö —Å–≤–µ—á–µ–π –¥–ª—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫
   * @returns {Object} —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∏—Å–æ–≤–∞–Ω–∏—è
   */
  drawVolumeProfileLines: (chart, volumeProfile, klineData) => {
    if (!chart || !volumeProfile || !klineData.length) {
      return { success: false, message: '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è Volume Profile' };
    }

    try {
      const firstTimestamp = klineData[0].timestamp;
      const lastTimestamp = klineData[klineData.length - 1].timestamp;

      // –õ–∏–Ω–∏—è POC (Point of Control) - —Å–∞–º—ã–π —Ç–æ—Ä–≥—É–µ–º—ã–π —É—Ä–æ–≤–µ–Ω—å
      const pocLine = {
        name: 'segment',
        id: 'poc_line',
        groupId: 'volume_profile',
        points: [
          { timestamp: firstTimestamp, value: volumeProfile.poc.price },
          { timestamp: lastTimestamp, value: volumeProfile.poc.price }
        ],
        styles: {
          line: {
            color: '#ff9800', // –û—Ä–∞–Ω–∂–µ–≤—ã–π –¥–ª—è POC
            size: 2,
            style: 'solid'
          }
        },
        extendLeft: true,
        extendRight: true
      };

      // –õ–∏–Ω–∏—è Value Area High (VAH)
      const vahLine = {
        name: 'segment',
        id: 'vah_line',
        groupId: 'volume_profile',
        points: [
          { timestamp: firstTimestamp, value: volumeProfile.valueArea.to },
          { timestamp: lastTimestamp, value: volumeProfile.valueArea.to }
        ],
        styles: {
          line: {
            color: '#4caf50', // –ó–µ–ª–µ–Ω—ã–π –¥–ª—è VAH
            size: 1,
            style: 'dashed'
          }
        },
        extendLeft: true,
        extendRight: true
      };

      // –õ–∏–Ω–∏—è Value Area Low (VAL)
      const valLine = {
        name: 'segment',
        id: 'val_line',
        groupId: 'volume_profile',
        points: [
          { timestamp: firstTimestamp, value: volumeProfile.valueArea.from },
          { timestamp: lastTimestamp, value: volumeProfile.valueArea.from }
        ],
        styles: {
          line: {
            color: '#4caf50', // –ó–µ–ª–µ–Ω—ã–π –¥–ª—è VAL
            size: 1,
            style: 'dashed'
          }
        },
        extendLeft: true,
        extendRight: true
      };

      console.log('üéØ –†–∏—Å—É–µ–º Volume Profile –ª–∏–Ω–∏–∏:', {
        poc: volumeProfile.poc.price.toFixed(4),
        vah: volumeProfile.valueArea.to.toFixed(4),
        val: volumeProfile.valueArea.from.toFixed(4)
      });

      // –°–æ–∑–¥–∞–µ–º –ª–∏–Ω–∏–∏ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ
      chart.createOverlay(pocLine);
      chart.createOverlay(vahLine);
      chart.createOverlay(valLine);

      return {
        success: true,
        message: `Volume Profile –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω: POC ${volumeProfile.poc.price.toFixed(4)}, VA ${volumeProfile.valueArea.from.toFixed(4)}-${volumeProfile.valueArea.to.toFixed(4)}`
      };

    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Ä–∏—Å–æ–≤–∞–Ω–∏—è Volume Profile:', error);
      return { success: false, message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∏—Å–æ–≤–∞–Ω–∏–∏ Volume Profile' };
    }
  },

  /**
   * –û—á–∏—â–∞–µ—Ç –≤—Å–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã —Å –≥—Ä–∞—Ñ–∏–∫–∞
   * @param {Object} chart - —ç–∫–∑–µ–º–ø–ª—è—Ä KLineChart
   * @returns {Object} —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ—á–∏—Å—Ç–∫–∏
   */
  clearAllIndicators: (chart) => {
    if (!chart) {
      return { success: false, message: '–ì—Ä–∞—Ñ–∏–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω' };
    }

    try {
      // –û—á–∏—â–∞–µ–º –≤—Å–µ –æ–≤–µ—Ä–ª–µ–∏
      chart.removeOverlay();
      
      console.log('üßπ –í—Å–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –æ—á–∏—â–µ–Ω—ã');
      
      return {
        success: true,
        message: '–í—Å–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã —É–±—Ä–∞–Ω—ã —Å –≥—Ä–∞—Ñ–∏–∫–∞'
      };
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤:', error);
      return {
        success: false,
        message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤'
      };
    }
  },

  /**
   * –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–±–æ—è —É—Ä–æ–≤–Ω–µ–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö —Å–≤–µ—á–µ–π
   * @param {Array} klineData - –º–∞—Å—Å–∏–≤ –¥–∞–Ω–Ω—ã—Ö —Å–≤–µ—á–µ–π
   * @param {Object} options - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–Ω–∞–ª–∏–∑–∞
   * @returns {Object} —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∞–Ω–∞–ª–∏–∑–∞ –ø—Ä–æ–±–æ—è
   */
  analyzeBreakout: (klineData, options = {}) => {
    const {
      lookbackPeriod = 20,     // –ø–µ—Ä–∏–æ–¥ –¥–ª—è –ø–æ–∏—Å–∫–∞ —É—Ä–æ–≤–Ω–µ–π
      volumeThreshold = 1.5,   // –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –æ–±—ä–µ–º–∞
      priceThreshold = 0.002   // –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã (0.2%)
    } = options;

    if (!klineData || klineData.length < lookbackPeriod) {
      return {
        hasBreakout: false,
        message: '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞'
      };
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ
    const recentData = klineData.slice(-lookbackPeriod);
    const currentCandle = recentData[recentData.length - 1];
    const previousCandles = recentData.slice(0, -1);

    // –ù–∞—Ö–æ–¥–∏–º —É—Ä–æ–≤–Ω–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
    const supportLevel = Math.min(...previousCandles.map(candle => candle.low));
    const resistanceLevel = Math.max(...previousCandles.map(candle => candle.high));

    // –°—Ä–µ–¥–Ω–∏–π –æ–±—ä–µ–º –∑–∞ –ø–µ—Ä–∏–æ–¥
    const avgVolume = previousCandles.reduce((sum, candle) => sum + candle.volume, 0) / previousCandles.length;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ–±–æ–π –≤–≤–µ—Ä—Ö (—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è)
    const breakoutUp = currentCandle.close > resistanceLevel * (1 + priceThreshold);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ–±–æ–π –≤–Ω–∏–∑ (–ø–æ–¥–¥–µ—Ä–∂–∫–∏)
    const breakoutDown = currentCandle.close < supportLevel * (1 - priceThreshold);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –æ–±—ä–µ–º–∞
    const volumeConfirmation = currentCandle.volume > avgVolume * volumeThreshold;

    let result = {
      hasBreakout: false,
      direction: null,
      strength: 'weak',
      supportLevel,
      resistanceLevel,
      currentPrice: currentCandle.close,
      volumeRatio: currentCandle.volume / avgVolume,
      message: '–ü—Ä–æ–±–æ—è –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ'
    };

    if (breakoutUp && volumeConfirmation) {
      result = {
        ...result,
        hasBreakout: true,
        direction: 'up',
        strength: 'strong',
        message: `üöÄ –ü—Ä–æ–±–æ–π —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è! –¶–µ–Ω–∞: ${currentCandle.close.toFixed(4)}, –£—Ä–æ–≤–µ–Ω—å: ${resistanceLevel.toFixed(4)}`
      };
    } else if (breakoutUp) {
      result = {
        ...result,
        hasBreakout: true,
        direction: 'up',
        strength: 'weak',
        message: `‚¨ÜÔ∏è –°–ª–∞–±—ã–π –ø—Ä–æ–±–æ–π —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è (–Ω–∏–∑–∫–∏–π –æ–±—ä–µ–º)`
      };
    } else if (breakoutDown && volumeConfirmation) {
      result = {
        ...result,
        hasBreakout: true,
        direction: 'down',
        strength: 'strong',
        message: `üìâ –ü—Ä–æ–±–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏! –¶–µ–Ω–∞: ${currentCandle.close.toFixed(4)}, –£—Ä–æ–≤–µ–Ω—å: ${supportLevel.toFixed(4)}`
      };
    } else if (breakoutDown) {
      result = {
        ...result,
        hasBreakout: true,
        direction: 'down',
        strength: 'weak',
        message: `‚¨áÔ∏è –°–ª–∞–±—ã–π –ø—Ä–æ–±–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏ (–Ω–∏–∑–∫–∏–π –æ–±—ä–µ–º)`
      };
    }

    return result;
  },

  /**
   * –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
   */
  formatResult: (analysis) => {
    const baseResult = {
      color: 'text-muted',
      icon: 'üìä',
      text: analysis.message,
      details: []
    };

    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª–∏–Ω–∏—è—Ö —ç–∫—Å—Ç—Ä–µ–º—É–º–æ–≤
    if (analysis.linesDrawn) {
      baseResult.details.push(`‚úÖ ${analysis.linesMessage}`);
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ Volume Profile
    if (analysis.volumeProfile) {
      const vp = analysis.volumeProfile;
      baseResult.details.push(`üìà ${analysis.volumeProfileMessage}`);
      baseResult.details.push(`üü† POC: ${vp.poc.price.toFixed(4)} (${vp.poc.volume.toFixed(0)} vol)`);
      baseResult.details.push(`üü¢ Value Area: ${vp.valueArea.from.toFixed(4)} - ${vp.valueArea.to.toFixed(4)}`);
      baseResult.details.push(`üìä –í—Å–µ–≥–æ –æ–±—ä–µ–º: ${vp.totalVolume.toFixed(0)}, –∫–æ—Ä–∑–∏–Ω: ${vp.histogram.length}`);
      
      if (analysis.vpLinesDrawn) {
        baseResult.details.push('‚úÖ Volume Profile –ª–∏–Ω–∏–∏ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω—ã');
      }
    } else if (analysis.volumeProfileMessage) {
      baseResult.details.push(`‚ùå Volume Profile: ${analysis.volumeProfileMessage}`);
    }

    if (!analysis.hasBreakout) {
      return baseResult;
    }

    const colors = {
      up: analysis.strength === 'strong' ? 'text-success' : 'text-warning',
      down: analysis.strength === 'strong' ? 'text-danger' : 'text-warning'
    };

    return {
      color: colors[analysis.direction],
      icon: analysis.direction === 'up' ? 'üöÄ' : 'üìâ',
      text: analysis.message,
      details: [
        ...baseResult.details,
        `üî¥ –ü–æ–¥–¥–µ—Ä–∂–∫–∞: ${analysis.supportLevel.toFixed(4)}`,
        `üî¥ –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ: ${analysis.resistanceLevel.toFixed(4)}`,
        `üìä –û–±—ä–µ–º: ${(analysis.volumeRatio * 100).toFixed(0)}% –æ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ`
      ]
    };
  }
};

/**
 * React –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∞–Ω–∞–ª–∏–∑–∞ –ø—Ä–æ–±–æ—è –≤ –≤–∏–¥–µ popover
 */
export const BreakoutDisplay = ({ analysis, onClose }) => {
  if (!analysis) return null;

  const formatted = BreakoutIndicator.formatResult(analysis);

  return (
    <div className="position-relative">
      <div 
        className="popover bs-popover-bottom show" 
        role="tooltip" 
        style={{
          position: 'absolute',
          top: '0px',
          left: '0px',
          right: '0px',
          zIndex: 1070,
          maxWidth: '500px',
          minWidth: '300px'
        }}
      >
        <div className="popover-arrow" style={{ left: '20px' }}></div>
        <div className="popover-header d-flex justify-content-between align-items-center">
          <span className="d-flex align-items-center">
            <span className="me-2" style={{ fontSize: '1.1em' }}>{formatted.icon}</span>
            <strong className={formatted.color} style={{ fontSize: '0.9em' }}>
              {formatted.text}
            </strong>
          </span>
          {onClose && (
            <button 
              type="button" 
              className="btn-close btn-close-sm" 
              onClick={onClose}
              aria-label="Close"
              style={{ fontSize: '0.8em' }}
            ></button>
          )}
        </div>
        {formatted.details && formatted.details.length > 0 && (
          <div className="popover-body">
            {formatted.details.map((detail, index) => (
              <div 
                key={index} 
                className="small text-muted mb-1"
                style={{ fontSize: '0.8em', lineHeight: '1.3' }}
              >
                {detail}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default BreakoutIndicator;